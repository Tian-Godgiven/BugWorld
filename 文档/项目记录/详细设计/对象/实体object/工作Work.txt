[TOC]

# 工作work对象

工作对象是需要占有虫群单位的工作量进行的，随着回合进行，能够产生对应效果的对象

## 属性

### 1.对象属性

~~~
名称 : 名称
需求 : 文本，对可参与这个工作的对象的需求描述
消耗 : 文本，对这个工作将要产生的消耗的描述
进度 : {
        now:该工作的当前进度
        max:完成这个工作所需要的总进度
    }
效率 : 符号数字，参与这个工作的对象所能提供的基础效率值，用作“效率”行为的参数
状态 : 状态数组
词条 : 词条数组
信息 : 文本，描述性信息
所属 : 对象，这个工作目前所属于的对象
~~~

### 2.行为

~~~
"开始" : 该工作在被startWork()调用时，执行的函数，变量为：work,bugNest
"需求" : 该工作对参与工作的单位的需求，接受object对象，判断其是否满足需求后返回true或false
"效率" : 单个参与该工作的object对象能为这个工作提供的“效率值”，接受object对象，返回单个的其所能提供的效率值
"效果" : 指名调用工作对象的”效果“时，若该工作的需求得到满足，产生的效果
结算 : 回合结束时，该工作对象产生的效果
"完成" : 回合结束时，若该工作的当前进度大于最大进度，调用的函数
"中断" : 在一个工作完成前，结束一个工作时调用的函数
"选择" : 进行选择时，产生选项并弹出对应的选择Tile，以及选择之后进行的函数
~~~

### 3.功能

~~~
“显示”：bool,默认为true
	若为true则表示这个工作会在“命令”栏等需要显示工作对象的地方显示
	若为false则不会在非强制显示的情况下显示
“选择”：bool，默认为false
	表示这个工作在开始前，需要进行一系列的选择，例如选择工作目标等。
	若为true，则会在需要时，执行这个工作对象的“选择行为”
“独立”：bool，默认为false，若“进度”不为Null或“无”，则默认为true
	若为true，则表示这个工作是独立进行的，可以同时存在复数个对应的工作对象，其属性会分别单独计算
		通常来说具有“进度”或类似设定的工作对象需要将这个属性设置为true
		在开始工作时，若“独立”为true，则会产生一个work对象的深拷贝，使用这个深拷贝为虫群对象绑定工作
“禁用”：bool，默认为false，若为true，则该工作对象无法被“开始”
“新增”：bool，默认为true，若为false，则该工作不会显示在“新增工作”菜单中
~~~

### 4.隐藏属性

​	一些不能被控制，或被控制后会影响到程序正常执行的属性值
~~~
进行中：bool，表示该工作对象当前是否正在进行中
	若为true则表示该工作正在进行中，对应的工作对象将不会显示在“工作Menu”中
	若为false则表示该工作尚未开始进行，或已经结束，对应的工作对象将会显示在“工作Menu”中
总效率：数字，表示该工作对象当前的总效率
占用：数组，内部存放着参与该工作占用的对象，通常是参与该工作的对象
~~~





## 方法

### 	1.通过key创造工作对象：createWork(work_key,source)

​		work_key：从json文件中获取工作对象的唯一key值
​		source：创造这个工作对象的来源

​		使用Work_lib中的key数据，创建并返回一个工作对象

### 2.使用数据创建工作对象：createWorkWithData(key,source,json,func)

​		key：工作对象的唯一key值，用于记录
​		source：创建来源
​		json：json数据，需要注意的是工作对象的json数据中包含“属性”和“功能”
​		func：工作对象的行为函数
​		
​		使用数据生成一个work对象，用于非Work_lib环境下的对象创建，例如设施对象的工作创建

### 	3.使得虫巢解锁工作对象：unlockWorkToBugNest( work,bugNest,source)

​		work：工作对象，或work_key字符串
​		bugNest：解锁这个工作对象的虫巢对象
​		*source：可选，对象，若传入work_key，则传入创造这个工作的来源

​		若work是work_key字符串，则使用work_key创建一个工作对象	
​			如果该工作对象的key不存在，则报错		
​		将指定的工作对象添加到虫巢对象的[已解锁→工作]数组中
​			如果这个工作已经存在于这个数组，则不会重复添加	

### 	4.删除目标对象中的，某一个来源的工作对象：deleteWorkFrom(*target*, *work_source*, *work*=null)

​		target：被删除的目标对象
​		work_source：作为标识的工作来源
​		*work：可选，将要被删除来源的工作对象
​		
​		若给定了work，则从指定work的来源中删除work_source
​		若未给出work，则从target的[已解锁→工作]中遍历，将所有拥有work_source来源的工作对象的work_source来源删除
​		如果删除后，工作对象不再具备来源，则从target中移除这个工作对象

### 	4.开始工作：startWork(bugNest,work)

​		bugNest：虫巢对象，
​		work：工作对象，或work_key字符串，表示将要在该虫巢内开始的工作

​		如果传入的是一个Work对象，则查询work是否存在于bugNest的[已解锁→工作]中
​		如果传入的是一个work_key，则查询在bugNest的[已解锁→工作]中是否存在对应work_key的工作对象，若找到则获取该工作对象为work
​		若判断该工作尚未解锁，则报错
​		若该work[功能→禁用]为true，则报错：该工作已被禁用，返回false
​		若该work[进行中] = true，则报错：该工作正在进行，返回false

​		若work的[功能→独立] == true，则产生一个深拷贝的工作对象为work
​		修改work的[进行中] = true
​		设置其“总效率” = 0
​		修改其[属性→所属]为bugNest
​		将其添加到bugNest[进行中]数组

​		执行work的[行为→开始]：参数（work,bugNest)
​		
​		向工作Tile中添加该工作的workDiv

### 5.结束工作：stopWork(work,type)

​		work:工作对象
​		
​		如果type为“中断”则执行work的[行为→中断]
​			否则不执行
​		解除work对象占用的对象，令其全部辞职
​		设置work的[进行中] = false
​		从work[属性→所属]的对象的[进行中]数组中删除work

​		从工作Tile中删除[data→work]为该工作的workDiv

### 	5.参加工作：joinWork(bug,num,work)

​		bug：参加工作的虫群对象
​		num：参加工作的虫群对象的数量
​		work：占用虫群对象的工作

​		判断bug对象是否满足work的[行为→需求]函数：参数(work, bug, num)
​		若返回true，则进一步判断bug的空闲数量是否足够大于等于num
​		若是，则令work对象占用num个bug对象（occupyBug(bug,num,work)
​		计算num个bug对象对work的效率加成，并将值加到work的“总效率”上

### 	6.退出工作：resignWork(bug,num,work)

​		bug,work同上5
​		num：将要退出工作的虫群单位的数量

​		判断bug对象是否被work对象所占有
​		若是，则获取work对象占有bug对象的数量，判断占有数量是否大于等于num
​		若是，则令work对象解除对Num个bug对象的占用（unoccupyBug(bug,num,work)
​		计算num个bug对象对work的效率加成，并将值从work的“总效率”上减少

### 	7.计算指定数量的虫群对象为工作对象提供的效率：countWorkEfficiency(*work*, *object*, *num*, *type*)

​		work：被计算效率的工作对象
​		object：提供效率的虫群单位
​		num：提供效率的虫群单位的数量
​		type：若为“unit”则返回的值中会加上效率的单位

​		使用work的[行为→效率]函数：参数(work,object)，计算object所能提供的单个效率并*num，得到效率值
​		如果work的[属性→效率]的值带有“+”或“-”符号，则为得到的效率值添加符号
​		如果type为“unit”，则为得到的效率值添加单位
​		最终返回得到的效率值

## 使用流程

​	1.通过addWorkToBugNest()，将指定work_key生成【工作】添加进【虫巢对象】的[已解锁→工作]属性当中
​	2.通过startWork()，令指定work_key的工作开始，并获得返回的工作对象
​	3.使用joinWork()，令指定数量的虫群单位参加返回的工作对象