[toc]



# State

state属性对象，是object实体对象的[属性]的值的基本单元，state大致可以分为三种：数值类，数组类，字典类，以及特殊的无类，表示没有该属性

## 结构/属性

通用结构：
~~~
来源:必须，对象或标识，这个属性的来源，若是object对象在创建时获得的属性，其来源为“基础”
类型:必须，为“数值”、“数组”、“字典”其一
~~~

数值类：

~~~
数值:必须，数值或字符串，是这个属性的值，即其当前正在受到的所有影响的累计
影响:必须，影响对象数组，是这个属性当前所受到的影响
单位:可选，字符串，这个属性专属的单位，在获取该属性的单位时，优先使用
~~~

数组类：
~~~
数组：必须，数组，这个数组属性的内容数组
数量：可选，非负整数，这个对象属性最多所能够包含的对象数量，若无设置则表示不对数组数量进行上限
~~~

字典类：
~~~
字典：必须，字典，这个字典属性的内容字典
单位：可选，字符串，如果这个属性内部嵌套了其他子属性，且这个子属性不具备[单位]在、则会使用与其最近的亲属性的单位
~~~

无类：
~~~
没有特殊的标签，获取该属性的值时，会返回“null”
~~~



## 方法

### 1.创建属性对象：createState(source,type,unit,num)

​	source：必须，创建该属性对象的来源
​	type：必须，该属性对象的类型，可选值包括："数值"、“数组”、“字典”
　*unit：可选，该属性对象的单位
​	*num：可选，非负整数 / “无限”，数组类属性对象的数组值的数量上限

​	创建一个属性对象，其[来源=source , 类型=type] 
​	若type为"数值"，则其[ 数值=null , 影响=[] , 单位=unit ]
​	若type为“数组”，则其[ 数组=[] , 数量=num ]，若未设置num则不存在“数量”属性
​	若type为“字典”，则其[ 字典={} , 单位=unit ]

​	最后返回这个属性对象

### 2.为指定对象加载指定json格式的属性数据，并将其添加到指定位置中：loadJsonStatesToObject(*object*,*state_belong*, *json_states* , *source* , *level*)

​	object：加载对应属性数据的对象
​	state_belong：数组或"属性"，对应属性数据所加载的位置，传入数组时，第一个元素必须是“属性”，且路径必须真实存在
​	json_states：json字典，加载到对应对象中的json格式的数据属性，每个属性的格式要求为以下三种其一：

1.声明类型或声明关键字，会优先使用属性内声明的类型作为该属性的类型

~~~
属性名:{
	*类型：可选，可为“数值”“数组”“字典”其中之一，该属性的类型
	数值 / 字典 / 数组：对应属性的类型必须存在其一，对应类型的数据，在创建属性对象后向其中填装的数据，在不声明类型的情况下，使用数组→数值→字典的顺序检测其中是否存在对应的关键字
	*单位：可选，这个属性在显示时的单位
	*优先级：可选，这个属性的数值所形成的影响的优先级，若不设置，则会使用level为该属性的优先级
	*数量：可选，仅当类型为“数组”时有效，数组属性内的值的最大数量
}
~~~

2.不声明类型，则会使用属性名→属性类型映射表尝试获取属性类型，若没有在映射表中获得属性类型，则根据其中的数据的类型以数组→数值→字典的顺序判断其属性类型

```
属性名：属性的数据，可以是数值 / 字典 / 数组
```

3.对于未设置[类型=“字典”]的字典属性，也可以使用如下格式的内容，此时即使属性类型映射表中不包含对应的属性名，也会默认使用“字典”类型，但是在该情况下子属性名不得与关键字重名

~~~
属性名：{
    子属性名1：{数值，单位……}
    子属性名2：{数值，单位……}
    *单位：可选
    *优先级：可选，如果在这里存在一个优先级，且其子属性没有设置优先级，会使用此处的优先级
}
~~~

​	source：必须，对象 / 标识 / 数组，这些属性的来源，所有json_states都会使用相同的来源，此外，json_states中的属性值/数值在加载的过程中，形成的影响对象，也会使用source作为来源
​	*level：可选，json_states中的属性值/数值在加载的过程中，若没有在属性内设置优先级时形成的影响对象所使用的优先级

​	依次读取json_states中的属性数据state_data
​	判断state_data的数据类型
​	若其为空，则类型为“无”
​	若其为数组，则类型为“数组”
​	若其为非字典和数组，则类型为“数值”
​	若类型为“字典”，则说明其中可能包含属性对象的说明，尝试从state_data中获得属性类型
​		若其中无声明类型则尝试从《属性名→属性类型映射表》（参见下方附录）中查询属性名对应的属性类型
​		若未查询到属性类型，则尝试按顺序查询关键字“数组”→“字典”→“数值”
​		若无关键字，则尝试判断state_data的数据类型是否为字典，若是则认为其属性类型的为“字典”
​	尝试获取其中的“单位”，“优先级”，“数量”，并生成state_object属性对象，将其填装到object的state_belong所在的state_name对应的位置（参见下3：appendStateObject()）
​	根据属性类型，处理属性对象中的数据
​	若为“数值“类，则获取state_data的[数值]或state_data本身，将其制成impact影响对象，装入state_object的[影响]中
​	若为“字典”类，则获取state_data的[字典]或state_data中移除关键字后剩余的键值对，递归调用本函数，将其读取到state_object的[字典]中
​	若为“数组”类，则获取state_data的[数组]或state_data本身，将其设定为state_object的[数组]的值

### 3.为指定的对象在指定位置添加一个指定名称的指定属性对象appendStateObject(object, state_belong, state_name, state_object)

​	object：必须，添加属性的对象
​	state_belong：这个属性在对象的“属性”中的位置，可选值包括：1.“属性”，2.object[属性]下的次级属性名，3.数组，根据数组内的内容，从最外层开始找，因此数组的第一位必须为“属性”
​	state_name：这个属性在指定位置中的标识名，也就是属性名
​	state_object：指定的属性对象

​	先通过state_belong查找指定的属性对象应该处于的位置
​	如果指定位置已经存在了一个相同state_name的属性对象，则将会使得这个已存在的属性对象与新传入的属性对象结合，将新传入的“来源”与“影响“添加到已存在的属性对象中，来源不会重复
​	否则在指定添加state_name : state_object

### 4.为一个对象新增一个json格式的属性数据：addStateTo(*object*, *source*, *state_path*, *state*)

​	object：新增属性所在的对象
​	source：新增属性的来源，或者说是何种来源将这个属性添加给这个对象的
​	state_path：新增属性所在的路径，这个路径可以是简化版的路径，只需要给出新增属性所需要处于的位置即可，可以传入一个数组，要求这个路径全过程实际存在，若不存在则会报错。举例如下：

```
例1
state_path = "参数"
→对应的对象结构→
object:{
	属性：{
		参数：{
			新增属性将在此处:xxx
		}
	}
}
例2
state_path = ["参数","a","min"]
→对应的对象结构→
object:{
	属性：{
		名称：xxxx
		参数：{
			a：{
				min：{
					新增属性将在此处
				}
				max：xxxx
			},
			b：xxxx,
```


​	state：这个属性的js格式内容，包括：
~~~
属性名：必须，字符串，这个属性的属性名
*类型：可选，“数值” / "数组“ / "字典“ 其一，声明这个属性对象类型
数值/数组/字典/子属性：对应“类型”至少存在其一，其中“子属性”对应字典类型
	数值：数字或字符串
	数组：数组
	字典：字典
	子属性：字典数组，其中的每个元素都是与该属性类似结构的js格式内容，这个属性的子属性
*单位：可选，字符串，这个属性的单位，如果子属性内部没有设置单位，则这些子属性会使用最接近的父属性的单位
*优先级：可选，优先级字符串或数字，默认为“basic” ，这个属性的优先级，若子属性没有设置优先级，则这些子属性会使用最接近的父属性的单位
~~~

​	该函数实质上是一个封装的json数据加载函数，其会将state_path整理为state_belong，将state整理为state_json，并调用loadJsonStatesToObject()将对应的state数据加载到指定对象中

### 5.删除指定对象的指定名称的属性的指定来源：deleteStateFrom(object,source,state_path)

​	object：必须，实体对象，被删除属性的对象
​	source：必须，实体对象 / 来源标识 / “all”字符串，被删除属性的来源
​	state_path：必须，字符串 / 字符串数组，被删除属性的名称 or 其所在的亲属性的名称构成的字符串+该属性的名称构成的数组

​	从object中找到state_path所指明的属性对象
​	若source为“all"字符串，则直接删除对应位置的该属性
​	否则将指定source从这个属性的”来源“值中删除，若在这之后属性对象的”来源“值为空，则删除这个属性对象

### 6.获得指定对象的指定属性名的指定类型的数值：stateValue(object,state_path,type)

​	object：必须，实体对象，读取指定属性的对象
​	state_path：必须，字符串 / 字符串数组，尝试获取值的属性的名称 or 其所在的亲属性的名称构成的字符串数组+该属性的名称构成的数组
​	type：可选，特定字符串，对返回的属性进行的处理
​		“symbol” => 若对应的属性值为数字，则会为≥0的值前方会添加”+“号，负数自带“-”号但也会转化为字符串
​		“num” => 返回的属性值变成纯数字，数字类型为int，多余的字符串会被删除
​		“stateObject" => 直接返回属性对象本身，而不是数值

​	从object中找到state_path所指明的属性对象
​	若type == stateObject，则在此处返回该属性对象
​	否则，根据属性对象的类型，获得对应的数值，数组，字典或null（类型为“无”）
​		对于数组属性，若其[数量 == 1]则会返回[数组]中的第一个（也是唯一一个元素）

​	按照type的要求进行加工得到的值
​	若要求传回的是“信息”，则调用“getInformation”函数，将这个返回的属性值加工

### 7.向指定对象的指定数组属性中添加一个指定值：pushToState(object,state_path,value)

​	object：必须，实体对象，指定的对象
​	state_path：必须，字符串 / 字符串数组，添加值的数组属性的名称 or 其所在的亲属性的名称构成的字符串数组+该数组属性的名称构成的数组
​	value：必须，通常为实体对象或实体对象数组，将要添加进该数组属性中的指定值

​	从object中找到state_path所指明的属性对象state_object
​	要求该属性对象的类型为“数组”，并且拥有[数组]属性，否则报错
​	判断该属性对象是否有[数量]上限且该上限不为“无限”
​		若有，判断state_object的[数组]在添加了value后其元素数量是否达到设定的上限
​			若是则返回false
​	将value添加进state_object的[数组]中，并返回true

### 8.从指定对象的指定数组属性中弹出一个指定值：popFromState(object,state_path,value)

​	object：必须，实体对象，指定的对象
​	state_path：必须，字符串 / 字符串数组，弹出值的数组属性的名称 or 其所在的亲属性的名称构成的字符串数组+该数组属性的名称构成的数组
​	*value：可选，通常为实体对象或实体对象数组，将要从该数组属性中弹出的指定值

​	从object中找到state_path所指明的属性对象state_object
​	要求该属性对象的类型为“数组”，并且拥有[数组]属性，否则报错
​	若value是数组，则依次检索其中的值是否存在在state_object中，并将结果依次存放进一个数组中，最终返回这个数组
​	若否则将检索value是否存在于该[数组]中
​		若不存在则返回false
​		若存在则将其删除，随后返回这个值
​	若未设置value，则将数组属性中的最后一位值 删除并返回

### 9.改变指定对象的指定数组属性的值：changeState(object,states,value)

​	object：必须，实体对象，指定的对象
​	state_path：必须，字符串 / 字符串数组，弹出值的数组属性的名称 or 其所在的亲属性的名称构成的字符串数组+该数组属性的名称构成的数组。
​	value：必须，实体对象 / 实体对象数组 / 由state_name和value组成的字典，指定数组属性的值改变后的值。

​	从object中找到state_path所指明的属性对象state_object
​	若value是一个字典，则要求state_object是字典类属性对象
​		遍历value中的键，从state_object的[字典]中寻找对应名称的子属性对象，并将其值修改为value中对应键的值
​	否则，要求state_object是数组属性，将其中的[数组]修改为value，如果这个value不是一个数组，则将其制成一个数组，此外，要求value中的元素数量不超过state_object["数量"]设定的上限

### 10.确认指定对象是否具备指定属性名的属性：haveState(object,state_path)

​	object：必须，实体对象
​	state_path：必须，字符串 / 字符串数组，到达目标属性的属性名路径

​	若state_path是一个数组，则尝试获取其中第一个元素在object中的属性路径
​		若没有找到则返回false
​		否则向该属性路径添加数组中剩余的元素，并尝试通过这个新的属性路径在object中查找属性对象。在该过程中若为属性对象，则在其[字典]中查询，否则直接查询。在该过程中任一查询结果为空时，说明不存在这样一个路径的属性对象，返回false
​		查询结束时，若查询对象是一个属性对象，则返回true
​		否则返回false
​	若state_path不是一个数组，则尝试获取其在object中的属性路径
​		若找到了这样一个路径，则说明属性对象存在，则返回true
​		否则返回false		

​	注意：如果对象具备的该属性名的属性的类型为“无”，本函数仍然会返回true，若要排除类型为“无”的情况，请使用stateValue()函数并设置type="stateObject"，在获取了属性对象后，判断其类型键的值

### 11.获取指定对象的指定属性的单位：getStateUnit(object,state_path)

​	object：必须，实体对象
​	state_path：必须，字符串 / 字符串数组，到达目标属性的属性名或属性名数组

​	从object中找到state_path所指明的属性对象state_object
​	优先获取state_object中的[单位]并返回
​	若没有设置，则从object的[单位]中获取对应state_path的单位值，此时要求state_path不为数组
​	若未找到有效的单位值，则返回空字符串，否则返回找到的单位值

### 12.从指定对象的属性中寻找到指定的属性对象：findState(object,state_path,type)

​	object：必须，实体对象
​	state_path：必须，字符串 / 字符串数组，目标属性对象的属性名或属性名路径数组
​	*type：可选，字符串"belong"，若为"belong"，则会返回该属性对象所处的对象

​	若state_path为数组，则提取其中第一个属性名元素，找到object到该属性对象的路径数组，并添加state_path数组中的剩余元素到路径数组中
​	否则找到object到state_path属性名元素的路径数组
​	若该路径有效，则从object开始依次寻找路径key所对应的对象，若对象是State属性对象则从[字典]中寻找路径key，否则直接寻找路径key，该过程中寻找到的对象无效时会报错
​	寻找结束时，若指定type="belong"则会找到并返回该属性对象所处的对象the_object，使用the_object[属性名]可获得该属性对象
​	否则直接返回该属性对象

### 13.从指定对象的属性中寻找到通往指定的属性对象的全过程路径：findStatePath(object,state_name)

​	object：必须，实体对象
​	state_name：必须，字符串，指定属性对象的属性名，请注意此处不接受字符串数组

​	递归调用内部函数，从object[属性]开始遍历，直到找到对应state_name的属性对象，将该过程中遍历的key按顺序保存在path数组中，若递归结果不为空，则返回该path数组，否则返回false

### 13.将对象的属性值填装进对应字符串的变量位置中：getInformation(object,info)

​	object：提取属性值的对象
​	info：一个字符串，其中包含有“${}"或/和"￥{}"标识符，标识符内部包含object的属性名或属性名数组

​	读取info当中的${}标识符中的字符串，视作其为属性名，从object中检索对应的属性值，并填装/替代对应的标识符位置，随后返回填装后的字符串
​	读取info当中的￥{}标识符中的字符串，视作其为可执行代码，使用object作为变量执行其中的内容，并用返回的值填装/替代对应的标识符位置，随后返回填装后的字符串
​	在没有指定info的情况下，会直接返回object的[属性→信息] 

## 附录

### 1.属性名→属性类型映射表

```
{
    "所属":"数组",
    "特性":"数组",
    "参数":"字典",
    "系数":"字典",
    "范围":"数组"
}
```
